1. Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

   

   a0,a1,a2é‡Œæœ‰å‚æ•°ï¼Œ13åœ¨a2å¯„å­˜å™¨ã€‚

2. Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

   åœ¨Cä»£ç ä¸­ï¼Œmainè°ƒç”¨fï¼Œfè°ƒç”¨gã€‚è€Œåœ¨ç”Ÿæˆçš„æ±‡ç¼–ä¸­ï¼Œmainå‡½æ•°è¿›è¡Œäº†å†…è”ä¼˜åŒ–å¤„ç†ã€‚

3. At what address is the function printf located?

   ä»ğ’„ğ’‚ğ’ğ’.ğ’‚ğ’”ğ’ç¬¬ 50 è¡Œçœ‹å‡º printf çš„åœ°å€åœ¨ 0x630

4. What value is in the register ra just after the jalr to printf in main?

   

   Ra å¯„å­˜å™¨ç”¨æ¥ä¿å­˜å‡½æ•°æ‰§è¡Œä»¥åçš„ä¸‹ä¸€ä¸ªæ‰§è¡ŒæŒ‡ä»¤çš„åœ°å€ï¼Œä¸º 0x38

   åˆ†æï¼š

   `auipc`(Add Upper Immediate to PC)ï¼š`auipc rd imm`ï¼Œå°†é«˜ä½ç«‹å³æ•°åŠ åˆ°PCä¸Šï¼Œè¯¥æŒ‡ä»¤å°†20ä½çš„ç«‹å³æ•°å·¦ç§»12ä½ä¹‹åï¼ˆå³ä¾§è¡¥0ï¼‰åŠ ä¸ŠPCçš„å€¼,å°†ç»“æœä¿å­˜åˆ°[rd]

   ![img](å®éªŒæŠ¥å‘Š.assets/p1.png)

   `jalr` (jump and link register)ï¼š`jalr rd, offset(rs1)`è·³è½¬å¹¶é“¾æ¥å¯„å­˜å™¨ã€‚jalræŒ‡ä»¤ä¼šå°†å½“å‰PC+4ä¿å­˜åœ¨rdä¸­ï¼Œç„¶åè·³è½¬åˆ°æŒ‡å®šçš„åç§»åœ°å€`offset(rs1)`ã€‚

    ![img](å®éªŒæŠ¥å‘Š.assets/p2.png)

   æ¥çœ‹XV6çš„ä»£ç ï¼š

   ```asm
     30: 00000097       auipc ra,0x0
     34: 600080e7       jalr  1536(ra) # 630 <printf>
   ```

   ç¬¬ä¸€è¡Œä»£ç ï¼š`00000097H=00...0 0000 1001 0111B`ï¼Œå¯¹æ¯”æŒ‡ä»¤æ ¼å¼ï¼Œå¯è§imm=0ï¼Œdest=00001ï¼Œopcode=0010111ï¼Œå¯¹æ¯”æ±‡ç¼–æŒ‡ä»¤å¯çŸ¥ï¼Œauipcçš„æ“ä½œç æ˜¯0010111ï¼Œraå¯„å­˜å™¨ä»£ç æ˜¯00001ã€‚è¿™è¡Œä»£ç å°†0x0å·¦ç§»12ä½ï¼ˆè¿˜æ˜¯0x0ï¼‰åŠ åˆ°PCï¼ˆå½“å‰ä¸º0x30ï¼‰ä¸Šå¹¶å­˜å…¥raä¸­ï¼Œå³raä¸­ä¿å­˜çš„æ˜¯0x30

   ç¬¬2è¡Œä»£ç ï¼š`600080e7H=0110 0...0 1000 0000 1110 0111B`ï¼Œå¯è§imm=0110 0000 0000ï¼Œrs1=00001ï¼Œfunct3=000ï¼Œrd=00001ï¼Œopcode=1100111ï¼Œrs1å’Œrdçš„çŸ¥è¯†ç éƒ½æ˜¯00001ï¼Œå³éƒ½ä¸ºå¯„å­˜å™¨`ra`ã€‚è¿™å¯¹æ¯”jalrçš„æ ‡å‡†æ ¼å¼æœ‰æ‰€ä¸åŒï¼Œå¯èƒ½æ˜¯æ­¤ä¸¤å¤„ä½¿ç”¨å¯„å­˜å™¨ç›¸åŒæ—¶ï¼Œæ±‡ç¼–ä¸­å¯ä»¥çœç•¥`rd`éƒ¨åˆ†ã€‚

   raä¸­ä¿å­˜çš„æ˜¯0x30ï¼ŒåŠ ä¸Š0x600åä¸º0x630ï¼Œå³`printf`çš„åœ°å€ï¼Œæ‰§è¡Œæ­¤è¡Œä»£ç åï¼Œå°†è·³è½¬åˆ°printfå‡½æ•°æ‰§è¡Œï¼Œå¹¶å°†PC+4=0X34+0X4=0X38ä¿å­˜åˆ°`ra`ä¸­ï¼Œä¾›ä¹‹åè¿”å›ä½¿ç”¨ã€‚

   æ•…Ra å¯„å­˜å™¨ç”¨æ¥ä¿å­˜å‡½æ•°æ‰§è¡Œä»¥åçš„ä¸‹ä¸€ä¸ªæ‰§è¡ŒæŒ‡ä»¤çš„åœ°å€ï¼Œä¸º 0x38ã€‚

5. Run the following code.

   ```
   unsigned int i = 0x00646c72;
   printf("H%x Wo%s", 57616, &i)
   ```

   What is the output? Here's an ASCII table that maps bytes to characters.

   The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set `i` to in order to yield the same output? Would you need to change `57616` to a different value?

   

   57616ç”¨16è¿›åˆ¶è¡¨ç¤ºä¸º0XE110ã€‚

   i,0x00646c72å°ç«¯å­˜å‚¨ä¸º72-6c-64-00ï¼Œå¯¹ç…§ASCIIç è¡¨,72:r 6c:l 64:d 00:å……å½“å­—ç¬¦ä¸²ç»“å°¾æ ‡è¯†ã€‚

   å› æ­¤è¾“å‡ºä¸ºï¼šHE110 World

   å¦‚æœ risc-v æ˜¯å¤§ç«¯åºï¼Œi éœ€è¦è®¾ç½®ä¸º 0x726c64ï¼Œ57616 ä¸éœ€è¦å˜

6. In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

   ```
   printf("x=%d y=%d", 3);
   ```

â€‹		è¾“å‡ºå½“å‰ a2 å¯„å­˜å™¨çš„å€¼ï¼Œæ‰€ä»¥ä¸ç¡®å®šã€‚